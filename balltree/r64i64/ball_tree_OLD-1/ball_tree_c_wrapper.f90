! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_BALL_TREE_R64
USE ISO_FORTRAN_ENV , ONLY : REAL64 , INT64
USE PRUNE , ONLY : LEVEL
USE SWAP , ONLY : SWAP_I64
USE FAST_SELECT , ONLY : ARGSELECT_R64
USE FAST_SORT , ONLY : ARGSORT
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_BUILD_TREE(POINTS_DIM_1, POINTS_DIM_2, POINTS, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, ORDER_DIM_1, ORDER, ROOT_&
&PRESENT, ROOT, LEAF_SIZE_PRESENT, LEAF_SIZE, COMPUTED_SQ_SUMS_PRESENT, COMPUTED_SQ_SUMS) BIND(C)
    USE BALL_TREE_R64, ONLY: BUILD_TREE
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: POINTS_DIM_1
    INTEGER, INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER, INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER, INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER, INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(ORDER_DIM_1) :: ORDER
    LOGICAL, INTENT(IN) :: ROOT_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: ROOT
    LOGICAL, INTENT(IN) :: LEAF_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    LOGICAL, INTENT(IN) :: COMPUTED_SQ_SUMS_PRESENT
    LOGICAL, INTENT(IN) :: COMPUTED_SQ_SUMS
  
    IF (ROOT_PRESENT) THEN
      IF (LEAF_SIZE_PRESENT) THEN
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, ROOT=ROOT, LEAF_SIZE=LEAF_SIZE, COMPUTED_SQ_SUM&
&S=COMPUTED_SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, ROOT=ROOT, LEAF_SIZE=LEAF_SIZE)
        END IF
      ELSE
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, ROOT=ROOT, COMPUTED_SQ_SUMS=COMPUTED_SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, ROOT=ROOT)
        END IF
      END IF
    ELSE
      IF (LEAF_SIZE_PRESENT) THEN
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, COMPUTED_SQ_SUMS=COMPUTED_&
&SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE)
        END IF
      ELSE
        IF (COMPUTED_SQ_SUMS_PRESENT) THEN
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, COMPUTED_SQ_SUMS=COMPUTED_SQ_SUMS)
        ELSE
          CALL BUILD_TREE(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER)
        END IF
      END IF
    END IF
  END SUBROUTINE C_BUILD_TREE
  

  
  SUBROUTINE C_NEAREST(POINTS_DIM_1, POINTS_DIM_2, POINTS, K, TREE_DIM_1, TREE_DIM_2, TREE, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RA&
&DII, ORDER_DIM_1, ORDER, LEAF_SIZE, INDICES_DIM_1, INDICES_DIM_2, INDICES, DISTS_DIM_1, DISTS_DIM_2, DISTS, TO_SEARCH_PRESENT, TO_&
&SEARCH) BIND(C)
    USE BALL_TREE_R64, ONLY: NEAREST
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: POINTS_DIM_1
    INTEGER, INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER(KIND=INT64), INTENT(IN) :: K
    INTEGER, INTENT(IN) :: TREE_DIM_1
    INTEGER, INTENT(IN) :: TREE_DIM_2
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(TREE_DIM_1,TREE_DIM_2) :: TREE
    INTEGER, INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER, INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER, INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(IN), DIMENSION(ORDER_DIM_1) :: ORDER
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER, INTENT(IN) :: INDICES_DIM_2
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1,INDICES_DIM_2) :: INDICES
    INTEGER, INTENT(IN) :: DISTS_DIM_1
    INTEGER, INTENT(IN) :: DISTS_DIM_2
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(DISTS_DIM_1,DISTS_DIM_2) :: DISTS
    LOGICAL, INTENT(IN) :: TO_SEARCH_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: TO_SEARCH
  
    IF (TO_SEARCH_PRESENT) THEN
      CALL NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDICES, &
&DISTS=DISTS, TO_SEARCH=TO_SEARCH)
    ELSE
      CALL NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDICES, &
&DISTS=DISTS)
    END IF
  END SUBROUTINE C_NEAREST
  

  
  SUBROUTINE C_PT_NEAREST(POINT_DIM_1, POINT, K, TREE_DIM_1, TREE_DIM_2, TREE, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, ORDER_DI&
&M_1, ORDER, LEAF_SIZE, INDICES_DIM_1, INDICES, DISTS_DIM_1, DISTS, CHECKS_PRESENT, CHECKS, FOUND_PRESENT, FOUND, PT_SS_PRESENT, PT&
&_SS) BIND(C)
    USE BALL_TREE_R64, ONLY: PT_NEAREST
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: POINT_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(POINT_DIM_1) :: POINT
    INTEGER(KIND=INT64), INTENT(IN) :: K
    INTEGER, INTENT(IN) :: TREE_DIM_1
    INTEGER, INTENT(IN) :: TREE_DIM_2
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(TREE_DIM_1,TREE_DIM_2) :: TREE
    INTEGER, INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER, INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER, INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(IN), DIMENSION(ORDER_DIM_1) :: ORDER
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER, INTENT(IN) :: DISTS_DIM_1
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(DISTS_DIM_1) :: DISTS
    LOGICAL, INTENT(IN) :: CHECKS_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: CHECKS
    LOGICAL, INTENT(IN) :: FOUND_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: FOUND
    LOGICAL, INTENT(IN) :: PT_SS_PRESENT
    REAL(KIND=REAL64), INTENT(IN) :: PT_SS
  
    IF (CHECKS_PRESENT) THEN
      IF (FOUND_PRESENT) THEN
        IF (PT_SS_PRESENT) THEN
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, CHECKS=CHECKS, FOUND=FOUND, PT_SS=PT_SS)
        ELSE
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, CHECKS=CHECKS, FOUND=FOUND)
        END IF
      ELSE
        IF (PT_SS_PRESENT) THEN
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, CHECKS=CHECKS, PT_SS=PT_SS)
        ELSE
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, CHECKS=CHECKS)
        END IF
      END IF
    ELSE
      IF (FOUND_PRESENT) THEN
        IF (PT_SS_PRESENT) THEN
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, FOUND=FOUND, PT_SS=PT_SS)
        ELSE
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, FOUND=FOUND)
        END IF
      ELSE
        IF (PT_SS_PRESENT) THEN
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS, PT_SS=PT_SS)
        ELSE
          CALL PT_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=INDI&
&CES, DISTS=DISTS)
        END IF
      END IF
    END IF
  END SUBROUTINE C_PT_NEAREST
  

  
  SUBROUTINE C_APPROX_NEAREST(POINTS_DIM_1, POINTS_DIM_2, POINTS, K, TREE_DIM_1, TREE_DIM_2, TREE, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DI&
&M_1, RADII, ORDER_DIM_1, ORDER, LEAF_SIZE, INDICES_DIM_1, INDICES_DIM_2, INDICES, DISTS_DIM_1, DISTS_DIM_2, DISTS, LOOK_AHEAD_PRES&
&ENT, LOOK_AHEAD) BIND(C)
    USE BALL_TREE_R64, ONLY: APPROX_NEAREST
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: POINTS_DIM_1
    INTEGER, INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER(KIND=INT64), INTENT(IN) :: K
    INTEGER, INTENT(IN) :: TREE_DIM_1
    INTEGER, INTENT(IN) :: TREE_DIM_2
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(TREE_DIM_1,TREE_DIM_2) :: TREE
    INTEGER, INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER, INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER, INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(IN), DIMENSION(ORDER_DIM_1) :: ORDER
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER, INTENT(IN) :: INDICES_DIM_2
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1,INDICES_DIM_2) :: INDICES
    INTEGER, INTENT(IN) :: DISTS_DIM_1
    INTEGER, INTENT(IN) :: DISTS_DIM_2
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(DISTS_DIM_1,DISTS_DIM_2) :: DISTS
    LOGICAL, INTENT(IN) :: LOOK_AHEAD_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: LOOK_AHEAD
  
    IF (LOOK_AHEAD_PRESENT) THEN
      CALL APPROX_NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=IN&
&DICES, DISTS=DISTS, LOOK_AHEAD=LOOK_AHEAD)
    ELSE
      CALL APPROX_NEAREST(POINTS=POINTS, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES=IN&
&DICES, DISTS=DISTS)
    END IF
  END SUBROUTINE C_APPROX_NEAREST
  

  
  SUBROUTINE C_PT_APPROX_NEAREST(POINT_DIM_1, POINT, K, TREE_DIM_1, TREE_DIM_2, TREE, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, O&
&RDER_DIM_1, ORDER, LEAF_SIZE, INDICES_DIM_1, INDICES, DISTS_DIM_1, DISTS, LOOK_AHEAD, FOUND_PRESENT, FOUND, PT_SS_PRESENT, PT_SS) &
&BIND(C)
    USE BALL_TREE_R64, ONLY: PT_APPROX_NEAREST
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: POINT_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(POINT_DIM_1) :: POINT
    INTEGER(KIND=INT64), INTENT(IN) :: K
    INTEGER, INTENT(IN) :: TREE_DIM_1
    INTEGER, INTENT(IN) :: TREE_DIM_2
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(TREE_DIM_1,TREE_DIM_2) :: TREE
    INTEGER, INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER, INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL64), INTENT(IN), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER, INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(IN), DIMENSION(ORDER_DIM_1) :: ORDER
    INTEGER(KIND=INT64), INTENT(IN) :: LEAF_SIZE
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER, INTENT(IN) :: DISTS_DIM_1
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(DISTS_DIM_1) :: DISTS
    INTEGER(KIND=INT64), INTENT(IN) :: LOOK_AHEAD
    LOGICAL, INTENT(IN) :: FOUND_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: FOUND
    LOGICAL, INTENT(IN) :: PT_SS_PRESENT
    REAL(KIND=REAL64), INTENT(IN) :: PT_SS
  
    IF (FOUND_PRESENT) THEN
      IF (PT_SS_PRESENT) THEN
        CALL PT_APPROX_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES&
&=INDICES, DISTS=DISTS, LOOK_AHEAD=LOOK_AHEAD, FOUND=FOUND, PT_SS=PT_SS)
      ELSE
        CALL PT_APPROX_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES&
&=INDICES, DISTS=DISTS, LOOK_AHEAD=LOOK_AHEAD, FOUND=FOUND)
      END IF
    ELSE
      IF (PT_SS_PRESENT) THEN
        CALL PT_APPROX_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES&
&=INDICES, DISTS=DISTS, LOOK_AHEAD=LOOK_AHEAD, PT_SS=PT_SS)
      ELSE
        CALL PT_APPROX_NEAREST(POINT=POINT, K=K, TREE=TREE, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, LEAF_SIZE=LEAF_SIZE, INDICES&
&=INDICES, DISTS=DISTS, LOOK_AHEAD=LOOK_AHEAD)
      END IF
    END IF
  END SUBROUTINE C_PT_APPROX_NEAREST
  

  
  SUBROUTINE C_FIX_ORDER(POINTS_DIM_1, POINTS_DIM_2, POINTS, SQ_SUMS_DIM_1, SQ_SUMS, RADII_DIM_1, RADII, ORDER_DIM_1, ORDER, COPY_P&
&RESENT, COPY) BIND(C)
    USE BALL_TREE_R64, ONLY: FIX_ORDER
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: POINTS_DIM_1
    INTEGER, INTENT(IN) :: POINTS_DIM_2
    REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
    INTEGER, INTENT(IN) :: SQ_SUMS_DIM_1
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(SQ_SUMS_DIM_1) :: SQ_SUMS
    INTEGER, INTENT(IN) :: RADII_DIM_1
    REAL(KIND=REAL64), INTENT(OUT), DIMENSION(RADII_DIM_1) :: RADII
    INTEGER, INTENT(IN) :: ORDER_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(ORDER_DIM_1) :: ORDER
    LOGICAL, INTENT(IN) :: COPY_PRESENT
    LOGICAL, INTENT(IN) :: COPY
  
    IF (COPY_PRESENT) THEN
      CALL FIX_ORDER(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER, COPY=COPY)
    ELSE
      CALL FIX_ORDER(POINTS=POINTS, SQ_SUMS=SQ_SUMS, RADII=RADII, ORDER=ORDER)
    END IF
  END SUBROUTINE C_FIX_ORDER
  
END MODULE C_BALL_TREE_R64

